# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                                                           #
#        beginning of multi-VCS package checkout, tarball creation          #
#        package building and OBS handling Makefile section; don't alter!   #
#                                                                           #
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                                                           #
#                   Please do not edit this file.                           #
#             This is not the Makefile you are looking for.                 #
#                      Look for Makefile.build.                             #
#                                                                           #
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

# -- Determine working directory and a few other key variables.
#
SHELL           := /bin/bash
DIRNAME         := $(abspath .)
DIRBASE         := $(notdir $(DIRNAME))
SPECFILE        := specfile.in
RPMSPEC         := $(shell which rpmspec 2>/dev/null)
ifeq ($(RPMSPEC),)
       RPMCMD := rpm -q --specfile $(SPECFILE)
else
       RPMCMD := $(RPMSPEC) -q $(SPECFILE)
endif
RPMINFO         := $(shell $(RPMCMD) --queryformat="%{NAME} %{VERSION} %{RELEASE}\n" 2>/dev/null  )
PACKAGE         := $(shell $(RPMCMD) --queryformat="%{NAME}\n" 2>/dev/null | head -n 1)

# -- OK, quick sanity check to make sure that the specfile.in passes
#    muster; normally 'rpm' is informative about errors, so we can just
#    short-circuit any further action if the above has failed.
#
ifeq ($(PACKAGE),)
  $(error Error reading/parsing specfile.in: is it valid? (try: rpm -q --specfile specfile.in))
endif

# -- OK, now keep going, if all is happy so far
#
PACKAGE         := $(word 1, $(RPMINFO))
VERSION         := $(word 2, $(RPMINFO))
RELEASE         := $(word 3, $(RPMINFO))
version_bits    := $(subst ., ,$(VERSION))
MAJOR_VERSION   := $(word 1,$(version_bits))
MAJOR_PACKAGE   := $(PACKAGE)-$(MAJOR_VERSION)
MINOR_VERSION   := $(word 1,$(version_bits)).$(word 2,$(version_bits))
MINOR_PACKAGE   := $(PACKAGE)-$(MINOR_VERSION)
BRANCHNAME      := $(MINOR_PACKAGE)

RPMDIST         := --define "_topdir $(DIRNAME)/build/"
DATE            := $(shell date +%F)
BUILD_HOST      := $(shell hostname)
BUILD_USER      := $(shell id -un)
ENCLAVE         := atelerix

SUBSCRIPT       := substitute.py
SUBDATA         := $(ENCLAVE).subdata
SCM_TYPE        := $(shell test -e .svn && echo svn || { test -e .git && echo git || { test -e .hg && echo hg || { echo test ; } ; } ; } )
CURRENT_PACKAGE := $(PACKAGE)-$(VERSION)
TARBALL         := $(CURRENT_PACKAGE).tar
SRPM            := $(PACKAGE)-$(VERSION)-$(RELEASE).src.rpm
BUILD_MAKEFILE  := Makefile.build
EXPORT_EXCL     := .extra-test-build-excludes

export PACKAGE VERSION SPECFILE SUBSCRIPT SUBDATA ENCLAVE

# -- Notes on above variables
#
# SHELL:  should be explicitly set to bash; otherwise build is occasionally
#         suspect to unexpected failures in a foreign shell (the shell in
#         this Makefile is bash)
# DIRNAME:  Required for rpmbuild--rpmbuild cannot deal with relative
#           directories.  Additionally required to determine DIRBASE.
# DIRBASE:  Required for the test build targets.  When attempting a build
#           from the user's home directory, need to fake the pathname to
#           create a tarball.  Therefore need to know what the real name is
#           (probably trunk) and make a symlink to $(PACKAGE)-$(VERSION)
# SPECFILE: Hard-coded name.  Always specfile.in.
# RPMCMD:   The command used to extract NAME and VERSION information from
#           the specfile.in.
# PACKAGE:  Yes, the package name.  Should be set only in specfile.in.
# VERSION:  Yes, the software version.  Should be set only in specfile.in.
# RPMDIST:  Boiler plate option when not using user's build environment.
# DATE:  A string date for substitution at build time.
# BUILD_HOST:  Name of the host on which the software was built.
# BUILD_USER:  Name of the user who built the software (Jack).
# ENCLAVE:  Name of the class of package, e.g. 'renesys', 'atelerix'
# SUBSCRIPT:  The equivalent of 'sed -e' using the subdata file.
# SUBDATA:  The name of the file containing the substitution data.
# SCM_TYPE:  By default, 'svn' inside Renesys.
# CURRENT_PACKAGE:  For tarball, dir, branch and tag naming, for example:
#                   frobnitz-0.4.2.
# TARBALL:  Name of the tarball (without path).
# BUILD_MAKEFILE:  The well-known name of the Makefile.build.



# -- Need to add a new variable?
#
#      - Put it here below
#      - export it (so it's available to "child" Makefiles)
#      - throw it in the $(SUBDATA) target for transformations
#
ROOT           := 
USRROOT        := $(ROOT)/usr
VAR            := $(ROOT)/var
ETC            := $(ROOT)/etc
PACKAGE_ETC    := $(ETC)/$(ENCLAVE)/$(PACKAGE)
PACKAGE_ROOT   := $(USRROOT)/lib/$(PACKAGE)
PACKAGE_SHARE  := $(USRROOT)/share/$(PACKAGE)
PACKAGE_SPOOL  := $(VAR)/spool/$(PACKAGE)
PACKAGE_CACHE  := $(VAR)/cache/$(PACKAGE)
PACKAGE_TMP    := $(VAR)/tmp/$(PACKAGE)
LIBEXEC        := $(USRROOT)/libexec
SHARE          := $(USRROOT)/share
MANDIR         := $(USRROOT)/share/man
BINDIR         := $(USRROOT)/bin
SBINDIR        := $(USRROOT)/sbin
NAGIOS_PLUGINS := $(USRROOT)/lib/nagios/plugins

export ROOT LIBEXEC SHARE MANDIR ETC BINDIR SBINDIR VAR NAGIOS_PLUGINS
export PACKAGE_ROOT PACKAGE_SHARE PACKAGE_ETC PACKAGE_CACHE PACKAGE_SPOOL
export PACKAGE_TMP DATE BUILD_HOST BUILD_USER

# -- weirdo extras
#
APACHE_ROOT=$(shell test -e /etc/SuSE-release && echo /etc/apache2 || echo /etc/httpd)

export APACHE_ROOT

default: build

# -- details needed for various SCM/VCS integration
#
ifeq ($(SCM_TYPE),svn)
  SVN_PATH        := $(shell svn info 2>/dev/null | awk '/^URL:/{print $$2}')
  SVN_PROJ        := $(subst branches/,,$(subst tags/,,$(dir $(SVN_PATH))))
  SVN_PROJSHORT   := $(lastword $(subst /, ,$(SVN_PROJ)))
  ifeq      ($(SVN_PROJSHORT),$(PACKAGE))
  else ifeq ($(SVN_PROJSHORT),$(MAJOR_PACKAGE))
  else ifeq ($(SVN_PROJSHORT),$(MINOR_PACKAGE))
  else ifeq ($(SVN_PROJSHORT),$(CURRENT_PACKAGE))
  else
    $(warning )
    $(warning Discrepancy:)
    $(warning )
    $(warning Specfile shows package name $(PACKAGE) )
    $(warning Subversion has project name $(SVN_PROJSHORT))
    $(warning See SVN path $(SVN_PATH))
    $(warning )
    $(warning Sleeping for 2 seconds before continuing anyway... )
    $(warning )
    $(shell sleep 2)
  endif
else ifeq ($(SCM_TYPE),git)
  GIT_ID          := remotes/svn/$(CURRENT_PACKAGE)
endif

# -- Notes on SCM/VCS variables
#
# SVN_PATH:  Full svn checkout path.
# GIT_ID:  Any "tree-ish" thing that you want to refer to.  For tagging and
#          branching and building from the git repo.


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                                                           #
#        end of preamble for package building out of git/svn/hg             #
#                                                                           #
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

.SUFFIXES:


# -- the "rpm" target will build out of the SCM, but will leave
#    the resulting package in the relative ./dist/ directory
#
.PHONY: test-rpm testrpm rpm-test rpmtest
test-rpm testrpm rpm-test rpmtest:
	$(MAKE) rpm SCM_TYPE=test

.PHONY: rpm
rpm: rpmlocaldist clean-builddir

.PHONY: srpm
srpm: srpmlocaldist clean-builddir

.PHONY: rpms
rpms: rpm

.PHONY: rpmlocaldist
rpmlocaldist: distdir buildrpm
	mv --verbose \
	    --target-directory ./dist/ \
	    build/$(PACKAGE)-$(VERSION)/$(PACKAGE).spec \
	    build/$(TARBALL).gz \
	    build/RPMS/*/*.rpm \
	    build/SRPMS/$(SRPM)

.PHONY: srpmlocaldist
srpmlocaldist: distdir buildsrpm
	mv --verbose \
	    --target-directory ./dist/ \
	    build/$(PACKAGE)-$(VERSION)/$(PACKAGE).spec \
	    build/SRPMS/$(TARBALL).gz \
	    build/SRPMS/$(SRPM)

.PHONY: buildsrpm
buildsrpm: buildtargz
	rpmbuild $(RPMDIST) -ts ./build/$(TARBALL).gz

.PHONY: buildrpm
buildrpm: buildtargz
	rpmbuild $(RPMDIST) -ta ./build/$(TARBALL).gz

.PHONY: buildtargz
buildtargz: buildtarball
	gzip -c < ./build/$(TARBALL) > ./build/$(TARBALL).gz

.PHONY: buildtarball
buildtarball: buildselectionhook
	tar \
	  --create \
	  --directory ./build/ \
	  --file      ./build/$(TARBALL) \
	  $(PACKAGE)-$(VERSION)

.PHONY: buildselectionhook
buildselectionhook: $(SCM_TYPE)-export
	cd ./build/$(CURRENT_PACKAGE) \
	  && $(MAKE) specfile

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                  test                                     #
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

.PHONY: test-tag
test-tag:
	echo test tag $(CURRENT_PACKAGE)

.PHONY: test-clean
test-clean:
	cd .. \
	  && ( test ! -L "$(CURRENT_PACKAGE)" || rm -f -- "$(CURRENT_PACKAGE)/$(EXPORT_EXCL)" "$(CURRENT_PACKAGE)" )

.PHONY: test-export
test-export: builddir
	cd .. \
	  && ln -snvf $(DIRBASE) $(CURRENT_PACKAGE) \
	  && tar \
	    --create \
	    --dereference \
	    --to-stdout \
	    $(patsubst %,--exclude "$(CURRENT_PACKAGE)/%",$(shell cat $(EXPORT_EXCL) )) \
	    --exclude "*.git*" \
	    --exclude "*.svn*" \
	    --exclude "*.hg*" \
	    --exclude "$(CURRENT_PACKAGE)/dist/*" \
	    --exclude "$(CURRENT_PACKAGE)/build/*" \
	      $(CURRENT_PACKAGE) \
	  | tar \
	    --extract \
	    --directory $(CURRENT_PACKAGE)/build/ \
	    --file -

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                   git                                     #
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

.PHONY: git-tag
git-tag:
	git tag \
	  -a -m $(CURRENT_PACKAGE) \
	  $(CURRENT_PACKAGE)

.PHONY: git-export
git-export: builddir
	git archive \
	  --format=tar \
	  --prefix=$(CURRENT_PACKAGE)/ \
	  $(GIT_ID) \
	  | tar \
	    --extract \
	    --directory ./build/ \
	    --file -

.PHONY: git-clean
git-clean:

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                   hg                                      #
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

# -- support for Mercurial needs more attention, but thanks to
#    estabroo@gmail.com for the beginnings...

.PHONY: hg-export
hg-export: builddir
	hg archive \
	  --prefix=$(CURRENT_PACKAGE)/ \
	  --type=tar \
	  $(HG_ID) \
	  - \
	  | tar \
	    --extract \
	    --directory ./build/ \
	    --file -

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                   SVN                                     #
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #


# -- ugly shell maneuvering in most of the below to make "nice glue" between
#    'svn' and 'make' which will interpret a non-zero exit as cause for
#    aborting the sequence
#

.PHONY: svn-trunk-must-be-pwd
svn-trunk-must-be-pwd:
	( test trunk == $(lastword $(subst /, ,$(SVN_PATH))) \
	  || { printf >&2 "%s\n" "Working directory must be a ./trunk/ to branch/tag." ; exit 1 ; } )

.PHONY: svn-branch-must-not-exist
svn-branch-must-not-exist:
	( svn ls $(SVN_PROJ)branches/$(BRANCHNAME) >/dev/null 2>&1 \
	  && { printf >&2 "%s\n" "Branch for $(CURRENT_PACKAGE) already exists." ; exit 1 ; } || exit 0 )

.PHONY: svn-tag-must-not-exist
svn-tag-must-not-exist:
	( svn ls $(SVN_PROJ)tags/$(CURRENT_PACKAGE) >/dev/null 2>&1 \
	  && { printf >&2 "%s\n" "Tag for $(CURRENT_PACKAGE) already exists." ; exit 1 ; } || exit 0 )

.PHONY: svn-branch-make
svn-branch-make: svn-branch-must-not-exist
	svn cp $(SVN_PATH)/ $(SVN_PROJ)branches/$(BRANCHNAME) \
	  -m "branch for $(CURRENT_PACKAGE)"

.PHONY: svn-tag-make
svn-tag-make: svn-tag-must-not-exist
	svn cp $(SVN_PATH)/ $(SVN_PROJ)tags/$(CURRENT_PACKAGE) \
	  -m "tag for $(CURRENT_PACKAGE)"

.PHONY: svn-branch
svn-branch: svn-branch-make

.PHONY: svn-tag
svn-tag: svn-tag-make

.PHONY: svn-export
svn-export: builddir
	cd ./build/ \
	  && svn export $(SVN_PATH) $(CURRENT_PACKAGE)

.PHONY: svn-clean
svn-clean:

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                               generic build                               #
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

.PHONY: branch
branch: $(SCM_TYPE)-branch

.PHONY: tag
tag: $(SCM_TYPE)-tag

.PHONY: clean
clean: $(SUBDATA) build-clean pkg-clean

.PHONY: mrclean
mrclean: clean

.PHONY: pkg-clean
pkg-clean:
	rm -f -- $(SUBSCRIPT) $(SUBDATA) $(PACKAGE).spec

.PHONY: builddir
builddir:
	rm -rf -- ./build/
	mkdir -p -- ./build/{SPECS,SOURCES,RPMS,SRPMS,BUILD}

.PHONY: distdir
distdir:
	rm -rf -- ./dist/
	mkdir -p ./dist

.PHONY: clean-builddir
clean-builddir: clean $(SCM_TYPE)-clean
       rm -rf -- ./build/ 2>/dev/null || :

.PHONY: clean-distdir
clean-distdir: clean $(SCM_TYPE)-clean
       rm -rf -- ./dist/ 2>/dev/null || :

.PHONY: distclean
distclean: obs-clean clean-builddir clean-distdir test-clean

# -- our own recursively called targets
#
.PHONY: specfile
specfile: $(SUBSCRIPT) $(SUBDATA) $(SPECFILE)
	python $(SUBSCRIPT) $(SUBDATA) < $(SPECFILE) > $(PACKAGE).spec

.PHONY: vars
vars: $(SUBDATA)
	cat $(SUBDATA)

$(SUBSCRIPT): Makefile
	@printf > $(SUBSCRIPT) "%s\n" \
	"#! /usr/bin/env python" \
	"import sys" \
	"" \
	"" \
	"def transform(mapping, text):" \
	"    for tag, replacement in mapping.iteritems():" \
	"        text = text.replace(tag, replacement)" \
	"    return text" \
	"" \
	"if 2 != len(sys.argv):" \
	"    sys.exit('usage: ' + sys.argv[0] + '<substitution_file>')" \
	"subst = dict(SUBDATA=sys.argv[1])" \
	"for line in open(sys.argv[1]):" \
	"    if line.startswith('#'):" \
	"        continue" \
	"    line = line.strip()" \
	"    if line == '':" \
	"        continue" \
	"    parts = line.split(None, 1)" \
	"    if len(parts) == 2:" \
	"        (k, v) = parts" \
	"    else:" \
	"        k = parts[0]" \
	"        v = ''" \
	"    k = '@' + k.strip() + '@'" \
	"    subst[k] = transform(subst, v.strip())" \
	"sys.stdout.write(transform(subst, sys.stdin.read()))" \
	"# -- end of file"

.PHONY: subdata $(SUBDATA)
subdata $(SUBDATA): pkg-$(SUBDATA) $(SUBDATA)-hook

.PHONY: pkg-$(SUBDATA)
pkg-$(SUBDATA):
	@printf > $(SUBDATA) "%s\t%s\n" \
	  PACKAGE        "$(PACKAGE)" \
	  VERSION        "$(VERSION)" \
	  MAJOR_VERSION  "$(MAJOR_VERSION)" \
	  MAJOR_PACKAGE  "$(MAJOR_PACKAGE)" \
	  MINOR_VERSION  "$(MINOR_VERSION)" \
	  MINOR_PACKAGE  "$(MINOR_PACKAGE)" \
	  DATE           "$(DATE)" \
	  BUILD_HOST     "$(BUILD_HOST)" \
	  BUILD_USER     "$(BUILD_USER)" \
	  RELEASE_DIST   "$(RELEASE_DIST)" \
	  ROOT           "$(ROOT)" \
	  NAGIOS_PLUGINS "$(NAGIOS_PLUGINS)" \
	  PACKAGE_ROOT   "$(PACKAGE_ROOT)" \
	  PACKAGE_SHARE  "$(PACKAGE_SHARE)" \
	  PACKAGE_CACHE  "$(PACKAGE_CACHE)" \
	  PACKAGE_SPOOL  "$(PACKAGE_SPOOL)" \
	  PACKAGE_ETC    "$(PACKAGE_ETC)" \
	  PACKAGE_TMP    "$(PACKAGE_TMP)" \
	  APACHE_ROOT    "$(APACHE_ROOT)" \
	  LIBEXEC        "$(LIBEXEC)" \
	  MANDIR         "$(MANDIR)" \
	  BINDIR         "$(BINDIR)" \
	  SBINDIR        "$(SBINDIR)" \
	  ETC            "$(ETC)" \
	  VAR            "$(VAR)" \
	  SHARE          "$(SHARE)"

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                    user-controlled per package stuff                      #
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

include $(BUILD_MAKEFILE)

# -- documentation target(s)
#
.PHONY: help
help:
	@printf "%s\n" \
	"Makefile for atelerix-based packages" \
	"------------------------------------" \
	"Valid targets are 'rpm', 'rpms' and 'rpmdist'." \
	"" \
	"  rpm     ('make rpm'):" \
	"  rpms    ('make rpms'):" \
	"" \
	"Specifying (either of) these targets will cause the packages to be" \
        "built into the relative directory ./build/.  If the build is succesful," \
        "the resulting RPM and SRPMs will be moved into the ./dist/ directory." \
	"" \
	"  rpmdist ('make rpmdist'):" \
	"" \
	"Specifying this target will not override the user-configured RPM build," \
	"environment thus allowing the user to build directly into an existing RPM-MD" \
        "repository.  Useful if you already have a build environment you wish to use." \
	"" \
	"By default, this package uses SCM_TYPE=$(SCM_TYPE).  You can control" \
	"which SCM_TYPE you would like to use for the build of this package by" \
	"setting the SCM_TYPE package type on the command line.  Here's how" \
	"you can build out of a working directory without checking in code:" \
	"" \
	"  make rpm SCM_TYPE=test" \
	"" \
	"Because building a test package is such a common pattern (building from" \
	"a working directory), there is a target just for building such a package," \
	"which is an exact analog of the above command." \
	"" \
	"  make test-rpm" \
	"" \
	"If you are using git, the rules are pretty much the same:" \
	"" \
	"  make rpm SCM_TYPE=git" \
	"  make rpm SCM_TYPE=git GIT_ID=HEAD" \
	"" \

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                                                           #
#                             end of Makefile                               #
#                                                                           #
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
